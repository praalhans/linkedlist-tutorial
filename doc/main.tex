\RequirePackage{amsmath}
\documentclass[runningheads]{llncs}

\usepackage{textcomp}
\usepackage{framed}
\let\proof\relax
\let\endproof\relax
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{fnpct}
\usepackage{enumitem}
\usepackage{dirtree}
\usepackage{listings}
\usepackage{subcaption}
\lstset{
language=Java,
columns=flexible,
numbers=left,
xleftmargin=3em,
frame=single,
framexleftmargin=3em,
keywordstyle=\rmfamily,
moredelim=[s][\rmfamily]{/*@}{*/},
moredelim=[l][\rmfamily]{//@}}

% Use multiple bibliographies
\usepackage{multibib}
\newcites{Self}{Self-references}

% Theorem style
\theoremstyle{remark}
\newtheorem{challenge}{Challenge}

\makeatletter
\DeclareRobustCommand*{\lyxarrow}{%
\@ifstar
{\leavevmode\,$\triangleleft$\,\allowbreak}
{\leavevmode\,$\triangleright$\,\allowbreak}}
\makeatother

\def\bs{\char092}

\begin{document}
% This makes sure lstlisting counts without section number, just like figures
\renewcommand{\thelstlisting}{\arabic{lstlisting}}

\title{A Tutorial on Verifying \texttt{LinkedList} using KeY}
\author{{Hans-Dieter} A. Hiep\orcidID{0000-0001-9677-6644}\footnote{Corresponding author: \texttt{hdh@cwi.nl}} \and Jinting Bian \and\\
Frank S. de Boer \and Stijn de Gouw}
\authorrunning{H.A. Hiep, J. Bian, et al.}

\institute{CWI, Science Park 123, 1098 XG Amsterdam, The Netherlands\\
\email{\{hdh,j.bian,frb,stijn.de.gouw\}@cwi.nl}}

\maketitle

\begin{abstract}
This is a tutorial paper on using KeY to demonstrate formal verification of state-of-the-art, real software. In sufficient detail for a beginning user of JML and KeY, the specification and verification of part of a corrected version of the \texttt{java.util.LinkedList} class of the Java Collection framework is explained. The paper includes video material that shows recordings of interactive sessions \citeSelf{Bian2020collection}, and project files with solutions \citeSelf{10.5281/zenodo.3613712}. As such, this material is also interesting for the expert user and the developer of KeY as a `benchmark' for specification and (automatic) verification techniques.
\end{abstract}

\keywords{Program correctness, linked list, theorem proving, KeY}

\section{Introduction}

Software libraries are the building blocks of many programs that run on the devices of many more users every day. The functioning of a system may rely for a large part on its used software libraries. A small error present in a heavily-used software library could lead to serious unwanted outcomes, such as system outages and failures. Using informal root cause analysis \cite{rooney2004root}, one could find from a system failure its root causes, which may include programming errors. But root cause analysis can only applied \emph{after} a failure has happened. To prevent certain failures from happening in the first place, program correctness is of the utmost importance. Although establishing program correctness seems to be an expensive activity, it may be worthwhile for critical software libraries, such the standard library that all programs rely on.

This tutorial intends to show how we take an existing Java program that is part of the Java standard library, and study it closely to increase our understanding of it. If we are only interested in showing the presence of an issue with the program, e.g.~that it lacks certain functionality, it suffices to show an example run which behaves unexpectedly. But to reach the conclusion that no unexpected behavior ever results from running the program, first requires a precise specification of what behavior one expects, and further requires a convincing argument that all possible executions of the program exhibit that behavior.

We take a formal approach to both specification and reasoning about program executions, allowing us to increase the reliability of our reached conclusions. In particular, the specifications we write are expressed in the Java Modeling Language (JML), and our reasoning is tool-supported and partially automated by KeY. To the best of the authors' knowledge, KeY is the only tool that supports enough features of the Java programming language for reasoning about real programs, of which its run-time behavior crucially depends on the presence of features such as: dynamic object creation, exception handling, integer arithmetic with overflow, \texttt{for} and \texttt{foreach} loops with early returns, nested classes (both static and non-static), inheritance, polymorphism, erased generics, etc.

As a demonstration of applying KeY to state-of-the-art, real software, we will focus on Java's \texttt{LinkedList} class, for two reasons. First, a (doubly-)linked list is a well-known basic data structure for storing and maintaining unbounded data, and has many applications: for example, in Java's secure sockets implementation. Second, it has turned out that there is a 20-year-old bug lurking in its program, that might lead to security-in-depth issues on large memory systems, caused by the overflow of a field that caches the length of the list \citeSelf{hiep2019verifying}. Our specification and verification effort will be aimed at establishing the absence of this bug from a repaired program.

This article is based on the results as described in another closely related paper \citeSelf{hiep2019verifying}. That paper provides a high-level overview on the specification and verification effort of the linked list class as a whole, for a more general audience. In the present article, more technical details how we use the KeY theorem prover are given, and we give more detail concerning the production of the proofs. In particular, this tutorial consists of the on-line repository of proof files \citeSelf{10.5281/zenodo.3613712}, and on-line video material that shows how to (re)produce the proofs \citeSelf{Bian2020collection}: these are video recordings of the interactive sessions in KeY that demonstrates exactly what steps one could take to complete the correctness proofs of the proof obligations generated by KeY from the method contracts.

\paragraph{Contents}
We see how to set-up a project and configure the KeY tool (Section~\ref{sec:setup}).
We then study the source code of the \texttt{LinkedList} to gain intuitive understanding of its structure:
how the instances look like, and how the methods operate (Section~\ref{sec:linkedlist}).
%A basic introduction to the KeY system is given, on which the rest of the tutorial is based (Section~\ref{sec:background}).
We formulate, based on previous intuition, a \emph{class invariant} in JML that expresses a property that is true of every instance (Section~\ref{sec:class-invariant}).
An interesting property that follows from the class invariant, that is used as a separation principle, is described next (Section~\ref{sec:acyclicity}).
To keep this presentation reasonably short, we further focus on the methods which pose the main challenges to formal verification, \texttt{add} and \texttt{remove}. We give a \emph{method contract} for the \texttt{add} method that describes its expected behavior and we verify that its implementation is correct (Section~\ref{sec:add}). The difficulty level increases after we specify the \texttt{remove} method (Section~\ref{sec:remove}), as its verification requires more work than before. We study a deeper method that \texttt{remove} depends on, and finally use \emph{loop invariants} to prove the correctness of \texttt{remove}.
We conclude with some proof challenges for the reader's recreation of further specifications and (in)formal proofs (Section~\ref{sec:conclusion}).

\section{Set-up}\label{sec:setup}

\begin{table}
\vspace*{-26pt}
\dirtree{%
.1 linkedlist-tutorial.
.2 key-2.6.3.zip.
.2 LinkedList.key.
.2 src.
.3 java.
.4 util.
.5 LinkedList.java.
.5 LinkedList.solution.
.2 jre.
.3 java.
.4 ....
.2 proof.
.3 ....
}
\medskip
    \caption{Directory structure of project files. The \texttt{src} directory contains the Java classes we want to specify and verify. The \texttt{jre} directory contains stub files, with specifications of unrelated classes. The \texttt{LinkedList.solution} file is the source file we end up with after following this tutorial. The \texttt{proof} directory contains the completed proofs.}
    \vspace*{-20pt}
    \label{tab:directory-structure}
\end{table}

First we will set-up the project files needed to use KeY. The project files are available on-line \citeSelf{10.5281/zenodo.3613712}: these can be downloaded and include the KeY software version that we use. After unpacking the project files, we end up with the directory structure of Table~\ref{tab:directory-structure}.

The original source file of \texttt{LinkedList.java} was obtained from OpenJDK version \texttt{jdk8-b132}. The original has been pre-processed: generic class parameters are removed, and all methods and nested classes irrelevant to this tutorial are removed. Both the removal of generics and the stub files in the \texttt{jre} folder were generated automatically, using the Eclipse extensions for KeY. Repeating those steps is not necessary here.

Over the course of next sections, we will modify the source file and add annotations to formally specify its behavior, and helper methods for presenting intermediary lemmas. The annotations are usual Java comments, and thus ignored when the file is read by a Java compiler. The helper methods introduce slight performance overhead (of calling a method that performs no operations, and immediately returning from it); it is clear that these do not change the original behavior of the program.

\subsection{KeY settings}

\begin{table}
\begin{subtable}[t]{.5\textwidth}
    \begin{tabular}[t]{l@{\hskip6pt}|@{\hskip6pt}l}
    Max. rule applications & 1000 \\
    Stop at & Default \\
    Proof splitting & Delayed \\
    Loop treatment & Invariant \\
    Block treatment & Contract \\
    Method treatment & Contract \\
    Dependency contract & On \\
    Query treatment & Off \\
    Expand local queries & On \\
    Arithmetic treatment & Basic \\
    Quantifier treatment & No splits \\
    \textbf{Class axiom rule} & \textbf{Off} \\
    Auto induction & Off \\
    User-defined taclets & All off
    \end{tabular}
    \medskip
    \caption{Proof search strategy}
    \label{tab:proof-strategy}
\end{subtable}%
\begin{subtable}[t]{.5\textwidth}
    \begin{tabular}[t]{l@{\hskip6pt}|@{\hskip6pt}l}
    \textbf{JavaCard} & \textbf{Off} \\
    Strings & On \\
    Assertions & Safe \\
    BigInt & On \\
    Initialization & Disable static ...  \\
    \textbf{Int Rules} & \textbf{Java semantics} \\
    Integer Simpl. Rules & Full \\
    Join Generate & Off \\
    Model Fields & Treat as axiom \\
    \textbf{More Seq. Rules} & \textbf{On} \\
    Permissions & Off \\
    Program Rules & Java \\
    Reach & On \\
    Runtime Exceptions & Ban \\
    Sequences & On \\
    Well-def. Checks & Off \\
    Well-def. Operator & L
    \end{tabular}
    \medskip
    \caption{Taclet options}
    \label{tab:taclet-options}
\end{subtable}
    \vspace*{-22pt}
    \caption{}
    \vspace*{-20pt}
\end{table}

To produce proofs in KeY, the first step is to set-up KeY's proof strategy and taclet options. This has to be done only once, as these taclet settings are stored per computer user. Sometimes, KeY overwrites or corrupts these settings if different versions are used. To ensure KeY starts in a fresh state, one can remove the \texttt{.key} directory from the user's home directory, and clean out preferences from the \texttt{.java/.userPrefs} directory by deleting the \texttt{de/uka/ilkd/key} hierarchy containing \texttt{prefs.xml} files\footnote{On Windows, the preferences are instead stored in the Windows Registry. Use the \texttt{regedit} tool and clean out under \texttt{HKEY\_CURRENT\_USER\bs Software\bs JavaSoft\bs Prefs} or \texttt{HKEY\_CURRENT\_USER\bs Software\bs Wow6432Node\bs JavaSoft\bs Prefs} the same hierarchy. On Mac OS, open a terminal, change directory to \texttt{\textasciitilde/Library/Preferences} and delete \texttt{de.uka.ilkd.plist}}. Now start up KeY, and the example selection screen appears (if not, selecting File\lyxarrow Load Example opens the same screen). Load any example, to enter proof mode. 

First, we set-up a proof strategy: this ensures the steps as done in the videos can be recreated. On the right side of the window, change the settings in the Proof Search Strategy tab to match those of Table~\ref{tab:proof-strategy}. We ensure to use particular taclet rules that correctly model Java's integer overflow semantics. Select Options\lyxarrow Taclet Options, and configure the options as in Table~\ref{tab:taclet-options}. The taclet options become effective after loading the next problem. We do that now: the main proof file \texttt{LinkedList.key} can be loaded, and a Proof Management window opens up, showing a class hierarchy and its methods. A method is not shown when no specifications for it are written. After giving specifications below, more methods can be selected in this window.

\section{\texttt{java.util.LinkedList}}\label{sec:linkedlist}

In this section we walk through part of the source code of Java's linked list: see the \texttt{LinkedList.java} file. Over the course of this tutorial, we add annotations at the appropriate places. We finally obtain the \texttt{LinkedList.solution} file.

\lstinputlisting[linerange=1-10,caption={The \texttt{LinkedList} class fields and constructor (begin of file).},captionpos=b,label={lst:linkedlist}]{figures/LinkedList.java}

Our \texttt{LinkedList} class has three attributes and a constructor (Listing~\ref{lst:linkedlist}). A \texttt{size} field, which stores a cached number of elements in the list, and two fields that store a reference to the first and last \texttt{Node}. The public constructor contains no statements: thus it initializes size to zero, and first and last to \texttt{null}.

The linked list fields are declared transient and package private. The transient flag is not relevant to our verification effort. The reason the fields are declared package private seems to prevent generating accessor methods by the Java compiler. However, in practice, the fields are treated as if they were private.

\lstinputlisting[firstnumber=65,linerange=65-77,caption={The \texttt{Node} nested class fields and constructor (end of file).},captionpos=b,label={lst:linkedlist-node}]{figures/LinkedList.java}

The \texttt{Node} class is defined as a private static nested class to represent the containers of items stored in the list (Listing~\ref{lst:linkedlist-node}). A static nested private class behaves like a top-level class, except that it is not visible outside the enclosing class. The nodes are doubly-linked, that is, each node is connected to its preceding node (through field \texttt{prev}) and succeeding node (through field \texttt{next}). These fields contain \texttt{null} in case no preceding or succeeding node exists. The data itself is contained in the \texttt{item} field of a node.

%bump page
\pagebreak

\lstinputlisting[firstnumber=39,linerange=39-43,caption={The method \texttt{add}.},captionpos=b,label={lst:linkedlist-add}]{figures/LinkedList.java}

The method \texttt{add} for adding elements to the list, takes one argument, the item to add (Listing~\ref{lst:linkedlist-add}). The informal Java documentation for \texttt{Collection} specifies it always returns \texttt{true}. The implementation immediately calls \texttt{linkLast}.

\lstinputlisting[firstnumber=45,linerange=45-63,caption={The method \texttt{remove}.},captionpos=b,label={lst:linkedlist-remove}]{figures/LinkedList.java}

The method \texttt{remove} for removing elements, also takes one argument, the item to remove (Listing~\ref{lst:linkedlist-remove}). If that item was present in the list, then its first occurrence is removed and \texttt{true} is returned; otherwise, if the item was not present, then the list is not changed and \texttt{false} is returned.

Presence of the item depends on whether the argument of the remove method is \texttt{null} or not. If the argument is \texttt{null}, then it searches for the first occurrence of a \texttt{null} item in the list. Otherwise, it uses the \texttt{equals} method, that every \texttt{Object} in Java has, to determine the equality of the argument with respect to the contents of the list. The first occurrence of an item that is considered equal by the argument is then returned. In both cases, the source code walks over the linked list, from the first node until it has reached the end. In the case that the node was found that contains the first occurrence of the argument, an internal method is called: \texttt{unlink}, and afterwards \texttt{true} is returned.

Observe that the linked list is not modified if \texttt{unlink} is not called. Although not immediately obvious, this requires that the \texttt{equals} method of every object cannot modify our current linked list, for the duration of the call to \texttt{remove}. When the \texttt{remove} method is called with an item that is not contained in the list, either loop eventually exits, and \texttt{false} is returned.

\lstinputlisting[firstnumber=11,linerange=11-18,caption={The internal method \texttt{linkLast}.},captionpos=b,label={lst:linkedlist-linkLast}]{figures/LinkedList.java}

The internal method \texttt{linkLast} changes the structure of the linked list (Listing~\ref{lst:linkedlist-linkLast}). After performing this method, a new node has been created, and the \texttt{last} field of the linked list now points to it. To maintain structural integrity, also other fields change: if the linked list were empty, the \texttt{first} field now points to the new, and only, node. If the linked list was not empty, then the new last node is also reachable via the former last node's \texttt{next} field. It is always the case that all items of a linked list are reachable through the \texttt{first} field, then following the \texttt{next} fields, and also for the opposite direction.

\lstinputlisting[firstnumber=20,linerange=20-37,caption={The internal method \texttt{unlink}.},captionpos=b,label={lst:linkedlist-unlink}]{figures/LinkedList.java}

The internal method \texttt{unlink} is among the most complex methods that alters the structure of a linked list (Listing~\ref{lst:linkedlist-unlink}). The method is used only when the linked list is not empty. Its argument is a node, necessarily one that belongs to the linked list. We first store the fields of the node in local variables: the old item, and next and previous node references.

After the method returns, the argument fields are all cleared, presumably to help the garbage collector. However, other fields also change: if the arguments is the first node, the \texttt{first} field is updated; if argument is the last node, the \texttt{last} field is updated. The predecessor or successor fields \texttt{next} and \texttt{prev} of other nodes are changed to maintain the integrity of the linked list: the successor of the unlinked node becomes the successor of its predecessor, and the predecessor of the unlinked node becomes the predecessor of its successor.

\begin{figure}
  \centering
  \includegraphics[width=0.8\textwidth]{figures/linkedlist1.eps}
  \caption{Three example linked lists: empty, with a chain of one node, and with a chain of two nodes. Items themselves are not shown.}
  \vspace*{-20pt}
  \label{fig:linkedlist}
\end{figure}

\subsection{Expected behavior}

We draw pictures of linked list instances to understand better how the structure looks like over time. In Fig.~\ref{fig:linkedlist}, we see three linked list instances. The left-most linked list is an object without any items: its \texttt{size} is zero. When we perform \texttt{add} with some item (it is not important what item), a new node is created and the first and last pointers are changed to point to the new node. Now the \texttt{prev} and \texttt{next} fields of the new node are \texttt{null}, indicating that there is no other node before and there is no other node after it. Also, the \texttt{size} field is increased by one. Adding another item further creates another node, that is linked up to the previous node properly; the \texttt{last} field is then pointed to the newly created node.
In the third instance, suppose we would perform \texttt{remove} with the first item. We would then have to unlink the node, see the code of \texttt{unlink} in Listing~\ref{lst:linkedlist-unlink}: the new value of \texttt{first} becomes the value of \texttt{next} which is the last node, and the value of \texttt{prev} of the succeeding node becomes the value of \texttt{prev} of the node that is unlinked, which is \texttt{null}. We thus end up in a similar situation as the second instance (except for the item that may be different). Removing the last item brings us back into the situation depicted by the first instance.

An important aspect of the implementation of our linked list is the cached \texttt{size} field: it represents the number of nodes that form a chain between \texttt{first} and \texttt{last}. It turns out an overflow may happen under certain conditions \citeSelf{hiep2019verifying}. Consider two facts: Java integer primitives are stored in signed 32-bit registers, and it is possible to create a chain that is larger than the maximum positive value that can be stored in such fields, $2^{31}-1$. Now, the cached size and the actual size no longer correspond. In the methods we have seen above, this seems to be no issue. But another method of the linked list may be used to demonstrate the key problem: \texttt{toArray}. The intention of \texttt{toArray} is to give back an array containing all the items of the list (see Listing~\ref{lst:linkedlist-toArray}). There are two problems: after the overflow has occurred and the \texttt{size} is negative, the \texttt{toArray} throws an unexpected \texttt{NegativeArraySizeException}. But, even worse, after adding more items that brings the size back to a positive integer, e.g. adding $2^{32}+1$ items in total, the returned array is of the wrong size and does not contain \emph{all} items of the list: without throwing an exception!

\lstinputlisting[numbers=none,caption={The method \texttt{toArray} has unexpected behavior.},captionpos=b,label={lst:linkedlist-toArray}]{figures/bug.java}

\subsection{Verification goal}

We thus revise the source code and add a method that implements an overflow check (see Listing~\ref{lst:linkedlist-fix}). The intention is that the overflow is signalled before it occurs, by throwing an exception. This ensures that the integrity of the linked list is always maintained. We modify the \texttt{add} method, and perform a call to this \texttt{checkSize()} method before invoking \texttt{linkLast}.

\lstinputlisting[numbers=none,caption={A new internal method \texttt{checkSize}.},captionpos=b,label={lst:linkedlist-fix}]{figures/fix.java}

Our aim in this tutorial is to keep the discussion abstract and general enough, without losing interesting particular details. We apply step-wise refinements to our arguments, where we start with a higher-level intuition and drill-down on technical details as they become relevant. The reader can always see the video material; but, a high-level intuition seems essential for following along.

Our specification and verification goals comprise two points:

\begin{enumerate}
    \item Specification captures the `intended' behavior of the methods with respect to its structural properties: in particular, we abstract away from all properties pertaining to the contents of the linked list.
    \item Verification ensures the overflow bug no longer happens in the revised linked list: the actual number of nodes and the cached size are always the same.
\end{enumerate}

The first point depends on the aim of a verification attempt. Are we using the specification to verify correctness of clients of the linked list? Then properties of the contents of a linked list are essential. But, for our purpose of showing the absence of an overflow bug, we abstract away some properties of the contents of linked lists. However, this abstraction is not yet fully complete, and the complete abstraction from contents is left as a proof challenge to the reader (see Section~\ref{sec:conclusion}).

The second point deserves an introduction: how can we be sure that in every linked list the number of nodes and the value stored in the size field are the same? Can we keep the number of nodes bounded by what a Java integer can represent? Keeping this number in a ghost field is not sufficient, since the number of nodes depends on the success of a \texttt{remove} call: removing an item not present in the linked list should not affect its size, while removing an item that is present decreases its size by one. We refine: we could keep track of the items that are stored by the linked list. The structure to collect these items in cannot be a set of items, since we could have duplicate items in the list. A multiset of items, the contents of a linked list, seems right: the size field of the linked list must be the same as the size of its contents, and the remove method is only successful if its argument was contained before the call.

However, working with multisets is quite unnatural, as the \texttt{remove} method removes the first item in the list. That can be refined by specifying the contents as a sequence of items instead. Although this could work in principle, a major difficulty when verifying the \texttt{remove} method is to give an argument as to why the method terminates. This requires knowledge of the linking structure of the nodes. We could relate the sequence of items to iterated traversal over nodes, saying that the first item of a linked list is found in the node by traversing \texttt{first}, and the item at index $0<i<n$ is found in the node by traversing \texttt{first} and then \texttt{next} for $i-1$ times. Formalizing this seems quite difficult, and as we shall see, not even possible in first-order logic.

Hence, we end up with our last refinement: we keep in a ghost field a sequence of nodes. From this sequence, one obtains the sequence of items. We relate the sequence of nodes to the linked list instance and require certain structural properties to hold of the nodes in the sequence. The length of this sequence is the actual number of nodes, that we show to be equal to the cached size.

%\input{key.tex}

\section{Class invariant}\label{sec:class-invariant}

We will now formalize a class invariant, thereby characterizing all linked list instances. We focus on unbounded linked lists first, as these are the structures we intend to model. Only at the latest we restrict the size of each linked list to a maximum, as a limitation imposed by the implementation. The setting in which to do our characterization is multi-sorted first-order logic. Our logic is presented in a simplified form, leaving out irrelevant details (such as the heap): the full logic used by KeY is described in Chapter 2 of \cite{KeYbook}.

Consider the following sorts, or type symbols: $\mathit{LinkedList}$ for a linked list, $\mathit{Node}$ for a node, $\mathit{Object}$ for objects and $\mathit{Null}$ for \texttt{null} values. We have a type hierarchy, where $\mathit{Null}$ is related to $\mathit{LinkedList}$ and $\mathit{Node}$, and $\mathit{LinkedList}$ and $\mathit{Node}$ are both related to $\mathit{Object}$. This means that any object of sort $\mathit{Null}$ is also an object of sort $\mathit{LinkedList}$ and $\mathit{Node}$. Moreover, every object that is a linked list is also of type $\mathit{Object}$, and similar for nodes.
We have the following signature: $\mathit{first}: \mathit{LinkedList}\to \mathit{Node}$ and $\mathit{last}: \mathit{LinkedList}\to \mathit{Node}$ for the \texttt{first} and \texttt{last} fields of linked lists, and $\mathit{prev}: \mathit{Node}\to \mathit{Node}$, $\mathit{item}: \mathit{Node}\to \mathit{Object}$, and $\mathit{next}: \mathit{Node}\to \mathit{Node}$ for the \texttt{prev}, \texttt{item} and \texttt{next} fields of nodes. Further, we assume there is exactly one object of $\mathit{Null}$ sort, which is the \texttt{null} constant, for which above functions are left undefined: \texttt{null} is a valid object of the \texttt{LinkedList} and \texttt{Node} Java types, but one may not access its fields.

We search for an axiomatization that characterizes linked lists. One can find these axioms by trial and error. We start listing some obvious axioms:

\begin{enumerate}
    \item $\forall x^\mathit{LinkedList}; (x \neq \mathtt{null} \to (\mathit{first}(x) \neq \mathtt{null} \leftrightarrow \mathit{last}(x) \neq \mathtt{null}))$\\
    Every linked list instance either has both first and last set to \texttt{null}, or both point to some (possibly different) node.
    \item $\forall x^\mathit{LinkedList}; (x \neq \mathtt{null} \to (\mathit{first}(x) \neq \mathtt{null} \to \mathit{prev}(\mathit{first}(x)) = \mathtt{null}))$\\
    The predecessor of the first node of a linked list is set to \texttt{null}.
    \item\label{item:axiom-last} $\forall x^\mathit{LinkedList}; (x \neq \mathtt{null} \to (\mathit{last}(x) \neq \mathtt{null} \to \mathit{next}(\mathit{last}(x)) = \mathtt{null}))$\\
    The successor of the last node of a linked list is set to \texttt{null}.
    \item\label{item:axiom-pred} $\forall x^\mathit{Node}; (x \neq \mathtt{null} \to (\mathit{prev}(x) \neq \mathtt{null} \to \mathit{next}(\mathit{prev}(x)) = x))$\\
    Every node that has a predecessor, must be the successor of that predecessor.
    \item\label{item:axiom-succ} $\forall x^\mathit{Node}; (x \neq \mathtt{null} \to (\mathit{next}(x) \neq \mathtt{null} \to \mathit{prev}(\mathit{next}(x)) = x))$\\
    Every node that has a successor, must be the predecessor of that successor.
\end{enumerate}

These axioms are not yet sufficient: consider a linked list, in which its first and last nodes are different and both have neither a predecessor nor a successor. This linked list should not occur: intuitively, we know that the nodes between first and last are all connected and should form a doubly-linked `chain'. Moreover, for every linked list, this chain is necessarily finite: one can traverse from first to last by following the next reference a finite number of times. This leads to a logical difficulty.

\begin{proposition}
It is not possible to define the reachability of nodes of a linked list in first-order logic.
\end{proposition}
\begin{proof}
Let $x$ be a linked list and $y$ a node: there is no formula $\phi(x,y)$ that is true if and only if $\mathit{next}^i(\mathit{first}(x))=y$ for some integer $i\geq 0$.\footnote{$\mathit{next}^i$ is not a function symbol in first-order logic but an abbreviation of a finite term built by iteration of $i$ times $\mathit{next}$, where $\mathit{next}^0(x)=x$ and $\mathit{next}^i(x)=next(\mathit{next}^{i-1}(x))$ for all $i>0$.}
Suppose towards contradiction that there is such a formula $\phi(x,y)$.
Now consider the infinite set $\Delta$ of first-order formulas $\{\phi(x,y)\}\cup\{\lnot(\mathit{next}^i(\mathit{first}(x))=y)\mid 0\leq i\}$. Let $\Gamma$ be an arbitrary finite subset of $\Delta$. Consider that there must exists some $j$ such that $\Gamma\subseteq \{\phi(x,y)\}\cup\{\lnot(\mathit{next}^i(\mathit{first}(x))=y)\mid 0\leq i<j\}$, so we can construct a linked list with $j$ nodes, and we interpret $x$ as that linked list and $y$ as the last node. Clearly $\phi(x,y)$ is true as the last node is reachable, and all $\lnot(\mathit{next}^i(\mathit{first}(x))=y)$ is true for all $0\leq i<j$ because $j$ is not reachable within $i$ steps from the first node. Since $\Gamma$ is arbitrary, we have established that all finite subsets of $\Delta$ have a model. By compactness, $\Delta$ must have a model too. However, that is contradictory: no such model for $\Delta$ can exists, as neither $\phi(x,y)$ and $\mathit{next}^i(\mathit{first}(x))\neq y$ for all integers $0\leq i$ can all be true.
\end{proof}

We extend our signature to include other sorts: sequences and integers. These sorts have their usual first-order theory. A schematic rule to capture integer induction is included (see \cite[Section 2.4.2]{KeYbook}). Sequences (see \cite[Chapter 5.2]{KeYbook}) have a non-negative integer length $n$, and consist of an element at each position $0\leq i<n$. We write $\sigma[i]$ to mean the $i$th element of sequence $\sigma$, and $\ell(\sigma)$ to mean its length $n$.

Intuitively, each linked list consists of a sequence of nodes between its first and last node. Let $\mathrm{instanceof}_\mathit{Node}: \mathrm{Object}$ be a built-in predicate that states that the object is not \texttt{null} and of sort $\mathit{Node}$. A \emph{chain} is a sequence $\sigma$ such that:

\begin{enumerate}[label=(\alph*)]
    \item\label{item:node} $\forall i^\mathrm{int}; (0\leq i<\ell(\sigma)\to \mathrm{instanceof}_\mathit{Node}(\sigma[i]))$\\
    All its elements are nodes and not \texttt{null}
    \item\label{item:prev} $\forall i^\mathrm{int}; (0<i<\ell(\sigma)\to \mathit{prev}(\sigma[i]) = \sigma[i-1])$\\
    The predecessor of node at position $i$ is the node at position $i-1$
    \item\label{item:next} $\forall i^\mathrm{int}: (0\leq i<\ell(\sigma)-1\to \mathit{next}(\sigma[i]) = \sigma[i+1])$\\
    The successor of node at position $i$ is the node at position $i+1$
\end{enumerate}

Let $\phi(\sigma)$ denote the above property that $\sigma$ is a chain. If $\ell(\sigma)=0$ then $\phi(\sigma)$ is vacuously true: the empty sequence is thus a chain. We now describe properties $\psi_1(\sigma,x)$ and $\psi_2(\sigma,x)$ that relate a chain $\sigma$ to a linked list $x$. These denote the following intuitive properties: there is no first and last node and the chain is empty, or the chain is not empty and the first and last node are the first and last elements of the chain. \begin{equation*}
\begin{split}
\psi_1(\sigma,x) & \equiv (\ell(\sigma) = 0 \land \mathit{first}(x) = \mathit{last}(x) = \mathtt{null}) \\
\psi_2(\sigma,x) & \equiv (\ell(\sigma) > 0 \land \mathit{first}(x) = \sigma[0] \land \mathit{last}(x) = \sigma[\ell(x)-1])
\end{split}
\end{equation*}
\begin{enumerate}\setcounter{enumi}{5}
    \item $\forall x^\mathit{LinkedList}; (x \neq \mathtt{null}\to \exists \sigma^\mathrm{sig}; (\phi(\sigma) \land (\psi_1(\sigma,x)\lor\psi_2(\sigma,x))))$\\
    Every linked list necessitates the existence of a chain of either property
\end{enumerate}

Further, we require that the size field of the linked list and the length of the chain are the same: this property is essential to our verification goal. The size field is modeled by the function $\mathit{size}: \mathit{LinkedList}\to \mathit{int}$, and we require its value (1) to equal the length of the chain, and (2) to be bounded by the maximum value stored in a 32-bit integer. In formulating above properties in JML, we skolemize the existential quantifier using a ghost field: see Listing~\ref{lst:jml-class-invariant}. This has the additional benefit that we can easily refer to the chain ghost field in specifications.

% push to next page
\medskip

\lstinputlisting[numbers=none,caption={The class invariant of \texttt{LinkedList} expressed in JML.},captionpos=b,label={lst:jml-class-invariant}]{figures/class_invariant.java}

The class invariant is implicitly required to hold for the \texttt{this} object when invoking methods on a linked list instance. In particular, for the constructor of the linked list, the class invariant needs to be established after it returns. In Listing~\ref{lst:jml-constructor}, we state that the constructor always constructs a linked list instance for which its chain is empty. The proof of the correctness follows easily: at construct time, the fields (including the ghost field) of the linked list instance are initialized with their default values. This means the size is zero, and the first and last references are \texttt{null}, and the ghost field is the empty sequence.

\lstinputlisting[numbers=none,caption={The method contract of the constructor of \texttt{LinkedList} in JML.},captionpos=b,label={lst:jml-constructor}]{figures/constructor.java}

For verifying the constructor above, see the video \citeSelf[0:23--0:53]{Bian2020addbranch}, where the relevant video material is between timestamps 0:23 and 0:53.

\section{Acyclicity}\label{sec:acyclicity}

An interesting consequence of the class invariant is the property that traversal of only \texttt{next} fields is acyclic. In other words, following only \texttt{next} references of any node that is present in a chain never reaches itself. The acyclicity property implies there is a number of times to follow the \texttt{next} reference until the last node is reached. For the last node, this number is zero (the last node is already reached). A symmetric property holds for \texttt{prev}.

We logically specify the acyclicity property as follows. Let $\sigma$ be the chain of a non-empty linked list $x$ for which the class invariant holds. The following holds:
$$
\forall i^\mathrm{int}; (0\leq i<\ell(\sigma)-1\to \forall j^\mathrm{int}; (i < j < \ell(\sigma)\to \sigma[i]\neq\sigma[j]))
$$

\begin{proof}
Let $n$ abbreviate $\ell(\sigma)$. By contradiction: assume there are two indices, $0\leq i<j<n$, such that the nodes $\sigma[i]$ and $\sigma[j]$ are equal.
Then it must hold that for all $k$ such that $j \leq k < n$, the node $\sigma[k]$ is equal to the node $\sigma[k-(j-i)]$:
by induction on $k$.
Base case: if $k = j$, then node $\sigma[j]$ and node $\sigma[j-(j-i)]$ are equal by assumption, since $\sigma[j-(j-i)]=\sigma[i]$.
Induction step: suppose node at $\sigma[k]$ is equal to node at $\sigma[k-(j-i)]$.
We must show if $k+1<n$ then node $\sigma[k+1]$ equals node $\sigma[k+1-(j-i)]$.
This follows from the fact that $\sigma[k+1] = \mathit{next}(\sigma[k])$ and $\sigma[k+1-(j-i)] = \mathit{next}(\sigma[k-(j-i)])$ for $k<n-1$, since $\sigma$ is a chain and the chain property \ref{item:next} of last section.
Now we have established, for all $j \leq k < n$, node $\sigma[k]$ equals node $\sigma[k-(j-i)]$.
In particular, this holds when $k$ is $n-1$, the index of the last node:
so we have $\sigma[n-1] = \sigma[n-1-(j-i)]$.
Since the difference $(j-i)$ is positive, we know $\sigma[n-1-(j-i)]$ is not the last node.
By the linked list property \ref{item:axiom-last} we have $\mathit{next}(\mathit{last}(x))=\mathtt{null}$
and by $\psi_2(\sigma,x)$ we have $\mathit{last}(x)=\sigma[n-1]$:
so we have $\mathit{next}(\sigma[n-1])=\mathtt{null}$.
By the chain properties \ref{item:next} and \ref{item:node} we have $\mathit{next}(\sigma[n-1-(j-i)])=\sigma[n-(j-i)]$
and $\mathrm{instanceof}_\mathit{Node}(\sigma[n-(j-i)])$, respectively.
From the latter we know $\sigma[n-(j-i)]\neq\mathtt{null}$.
So we have $\mathit{next}(\sigma[n-1-(j-1)])\neq\mathtt{null}$.
But this is a contradiction: if nodes $\sigma[n-1]$ and $\sigma[n-1-(j-i)]$ are equal then their \texttt{next} fields must also have equal values, but $\mathit{next}(\sigma[n-1])=\mathtt{null}$ and $\mathit{next}(\sigma[n-1-(j-i)])\neq\mathtt{null}$!
\end{proof}

\lstinputlisting[numbers=none,caption={The method of a lemma added to \texttt{LinkedList} expressed in JML.},captionpos=b,label={lst:jml-lemma}]{figures/lemma_method.java}

For verifying the lemma as formalized in Listing~\ref{lst:jml-lemma}, see the video \citeSelf{Bian2020lemma}.

\section{The \texttt{add} method}\label{sec:add}

Due to the revision of the source code, the add method now calls \texttt{checkSize} first (see Listing~\ref{lst:linkedlist-fix}) to ensure that the size field does not overflow when we add another item. This means that the add method has two expected behaviors: the normal behavior when the length of the linked list is not yet at its maximum, and the exceptional behavior when the length of the linked list is at its maximum.

In the normal case, we expect the \texttt{add} method to add the given argument as an item to the linked list. Thus the sequence of nodes must become larger. We further specify the position where the item is added: at the end of the list. If add return normally, it returns true. In the exceptional case, we expect that an exception is thrown. We formalize the contract for \texttt{add} in Listing~\ref{lst:jml-add-method}.

\lstinputlisting[numbers=none,caption={The \texttt{add} method with its method contract expressed in JML.},captionpos=b,label={lst:jml-add-method}]{figures/add_method.java}

Since the \texttt{add} method calls the deeper methods \texttt{checkSize} and \texttt{linkLast}, we may employ their method contracts when verifying this method. So, before we verify \texttt{add}, we will first specify and verify these methods.

We expect \texttt{checkSize} to throw an exception if the length of the linked list is too large to add another element, and it returns normally otherwise: see Listing~\ref{lst:jml-check-method} for its specification. Verification of \texttt{checkSize} in both normal and exceptional cases is done automatically by KeY, as can be seen in \citeSelf[0:54--1:24]{Bian2020addbranch}.

\lstinputlisting[numbers=none,caption={The method contract in JML of the \texttt{checkSize} method.},captionpos=b,label={lst:jml-check-method}]{figures/check_method.java}

For the \texttt{linkLast} method, we assume that the length of the linked list is smaller than its maximum length, so we can safely add another node without causing an overflow of the size field. When adding a new node, the resulting chain now is an extension of the previous chain, and additionally the class invariant holds afterwards---this is an implicit post-condition. Since we modify the chain, we need a \texttt{set} annotation that changes the ghost field.

\lstinputlisting[numbers=none,caption={The \texttt{linkLast} method with its method contract expressed in JML.},captionpos=b,label={lst:jml-linklast-method}]{figures/linklast_method.java}

The verification of this method is no longer fully automatic, see \citeSelf[1:25--6:52]{Bian2020addbranch}.

\begin{proof}
Observe that there are two different situations we have to deal with: either the linked list was empty, or it was not. If the linked list was empty, then \texttt{last} is \texttt{null}, and we not only set the \texttt{last} field but also the \texttt{first}. Otherwise, if the linked list was not empty, we update the former last node to set its \texttt{next} field. The challenge is to prove that the class invariant holds after these heap updates, knowing that the class invariant holds in the before heap. The main insight is that the creation of a new node does not alias with any of the existing nodes, and that the modification of the \texttt{next} field only affects the old last node. Intuitively, we have a proof situation with two heaps as depicted in Fig.~\ref{fig:linklast}.

The properties \ref{item:prev}, that fixes \texttt{prev} fields to point to the previous node in the sequence, and \ref{item:next}, that fixes \texttt{next} fields to point to the next node in the sequence, of the chain are the remaning goals in \citeSelf[3:58]{Bian2020addbranch}. Proving \ref{item:prev} is straightforward if one makes a distinction between old nodes and the new node. Proving \ref{item:next} in the `heap after' involves two cases: either the index is between $0$ and less than $\ell(\sigma)-2$, or it used to be the last node and now has index $\ell(\sigma)-2$. In the former case, the heap update has no effect, as we can show that these nodes are separate from the old last node because they differ in the old value of the next field. In the latter case, the heap update can be used to prove the property directly.
\end{proof}

\begin{figure}
   \vspace*{-12pt}
   \centering
   \includegraphics[scale=1]{figures/linkedlist-linklast.eps}
   \caption{The heap before ($H_b$) consists of an arbitrary chain of nodes. In the heap after ($H_a$) the dashed lines show which objects are identical to the heap before. The old last node at $\sigma[\ell(\sigma)-1]$ has a different value for its $\mathit{next}$ field in the heap after: this must be the result of a heap update. The new last node does not occur in the heap before: this must be the result of creating a new node.}
   \vspace*{-12pt}
   \label{fig:linklast}
\end{figure}

Finally, we can verify the \texttt{add} method: see \citeSelf[6:58]{Bian2020addbranch} for the normal behavior case, and \citeSelf[8:09]{Bian2020addbranch} for the exceptional behavior case.

\section{The \texttt{remove} method}\label{sec:remove}

The \texttt{remove} method takes as argument an object; it searches the linked list for the first node which contains the argument as an item. If found, it unlinks the node from the linked list. Using this intuition, we specify the \texttt{remove} method contract. Like with the \texttt{add} method, there is a deeper method that is called, \texttt{unlink}, which we have to specify and verify first.

An immediate difficulty in specifying the \texttt{remove} method contract is that its intended behavior depends on the behavior of the \texttt{Object.equals} method. Namely, the informal Java documentation states that the first element occurrence in the list that is `equal to' the argument must be removed. Equality can be user-defined by overriding the \texttt{equals} method! We solve this difficulty by assuming a method contract for the equality method, see Listing~\ref{lst:object-equals}.

\lstinputlisting[numbers=none,caption={The \texttt{equals} stub method with its method contract expressed in JML.},captionpos=b,label={lst:object-equals}]{figures/equals_method.java}

We declare the equality method to be strictly pure, which implies that it must be a side-effect free and terminating method (see \cite[Section 7.3.5]{KeYbook}). Each strictly pure method is also directly accessible as an observer symbol (a function symbol) that can be used in specifications (see \cite[Section 8.1.2]{KeYbook}). However, no obvious relation between the possibly overridden equality method and its observer symbol is present. The intention of the contract given in Listing~\ref{lst:object-equals} is to relate the outcome of the method call of \texttt{equals} to the observer symbol $\mathit{equals}$, and this furthermore requires that the implementation is deterministic.

It is not clear what ramifications adding this assumption has. We note that there are Java classes for which equality is not terminating under certain circumstances. Even \texttt{LinkedList} itself does not have a terminating equality, where two linked lists that contain each other may lead to a \texttt{StackOverflowError} when testing their equality. This example is described in the Javadoc \cite{javadoc8collection} of the linked list: ``Some collection operations which perform recursive traversal of the collection may fail with an exception for self-referential instances where the collection directly or indirectly contains itself.'' Another approach is to specify the outcome of equality as referential equality only, e.g. see \cite[Section 4.4]{huisman2002verification}.

Now we can specify the behavior of remove. It can be seen as consisting of two cases: either its result is \texttt{true} and it has removed the first item equal to its argument from the list, or its result is \texttt{false} and the argument was not found and thus not removed. In the first case, the number of elements in the linked list remain unchanged. In the second case, the number of elements decrease by one. See Listing~\ref{lst:remove-method}.

\lstinputlisting[numbers=none,caption={The \texttt{remove} method contract expressed in JML.},captionpos=b,label={lst:remove-method}]{figures/remove_method.java}

It is important to note that we make use of JML's \texttt{\bs old} operator to refer to the equality observer symbol in the old heap. Using equality in the new heap is a different observation; and it should not be possible to verify the remove method in this case. To see why, consider two linked list instances $x$ and $y$: we add $x$ to itself, and to $y$ we add $x$ and then $y$. Now we perform the \texttt{remove} operation on $y$ with $y$ as argument. Clearly $x$ and $y$ are not equal, because they have a different length. But the second item is $y$ itself, and $y$ equals $y$, so it is removed: see Fig.~\ref{fig:remove-equals}. In the resulting heap, both $x$ and $y$ contain $x$ as only item: thus, $x$ and $y$ are equal. If we wrongly observe equality in the new heap, then the implementation would be incorrect: the item to remove should not be the second but the first!

\begin{figure}
   \vspace*{-10pt}
   \centering
   \includegraphics[width=\textwidth]{figures/linkedlist-remove-equals.eps}
   \caption{The situation ($H_b$) before \texttt{remove} is invoked on $y$ with argument $y$, and after ($H_a$). The result of this operation is that $y$'s second node $n_3$ is unlinked, hence the first node $n_2$ becomes the last node and its next pointer is cleared: now $x$ and $y$ are equal because they have the same length, and they have the same item, namely $x$.}
   \vspace*{-20pt}
   \label{fig:remove-equals}
\end{figure}

Before we can verify the \texttt{remove} method, we must specify and verify its deeper method: \texttt{unlink}. Within the method of unlink we have to update the chain ghost field as well, to remove a node from the sequence, so we add a set annotation to the method body. Additionally, we will make use of the lemma \texttt{lemma\_acyclic} by calling it as a first statement of the method. See Listing~\ref{lst:unlink-method}. This method call is also not present in the original definition for \texttt{unlink}, but we already argued that it does not affect behavior.

\lstinputlisting[numbers=none,caption={The first part of method \texttt{unlink} and its method contract. Note that the @set annotation must not contain a new line, but kept on a single line: otherwise KeY 2.6.3 cannot load the source file.},captionpos=b,label={lst:unlink-method}]{figures/unlink_method.java}

An interesting aspect of the specification of \texttt{unlink} is its use of a \emph{ghost parameter}. Although KeY does not directly support ghost parameters, we are able to work around by adding the parameter as a ghost field to our class:
$$\mathrm{//@\ private\ ghost\ \bs bigint\ nodeIndex;}$$
Its value is left undefined for the most part of the lifetime of the linked list, until we are about to invoke \texttt{unlink}. In particular, the ghost parameter contains the index of the node argument, thereby requiring that the node object passed in is part of the chain. In the following discussion, let $I$ be the node index ghost parameter and $\sigma$ the chain of the linked list: then $\sigma[I]$ is assumed to be the node argument of the method \texttt{unlink}.

The verification of the unlink method is not fully automatic, see the five videos \citeSelf{Bian2020unlink1truetrue,Bian2020unlink2truefalse,Bian2020unlink3falsetrue,Bian2020unlink4falsefalseprev,Bian2020unlink5falsefalsenext}.

\begin{proof}
Verifying unlink consists of four main cases: these correspond to the possible branches of the two if-statements (see Listing~\ref{lst:linkedlist-unlink}). The challenge again is to reestablish the class invariant in the heap after the method completes. The main insight is that, by the acyclicity property, all the nodes are separate: this allows us to distinguish the heap updates to apply only to the node that is actually affected, while leaving the other nodes equal to the situation in the heap before. The three important cases are depicted in Figs.~\ref{fig:unlink-first}, \ref{fig:unlink-last}, \ref{fig:unlink-middle} (compare with Fig.~\ref{fig:linklast}).

\begin{enumerate}
    \item Suppose the test of both if-statements evaluate to true: for node $x$, it holds that $\mathrm{next}(x)=\mathtt{null}$ and $\mathrm{prev}(x)=\mathtt{null}$. Then we know the list consists of exactly one node, as the node we are unlinking is the first and the last node. So $I$ cannot be larger than 0. In the case the node index is zero, the class invariant is proven automatically \citeSelf[7:25]{Bian2020unlink1truetrue}.
    
\begin{figure}
   \centering
   \includegraphics[scale=1]{figures/linkedlist-unlink-first.eps}
   \caption{The heap before ($H_b$) consists of a chain $\sigma$ with $\ell(\sigma)\geq 2$. The dashed lines show which objects are identical in the heaps.  Interpreting $\sigma[I]$ in the new heap gives $\sigma[I+1]$ in the old heap, as $I$ does not change. The \texttt{first} field of the linked list has changed (not shown), and the second node in the old heap now has \texttt{null} as \texttt{prev}. Moreover, the \texttt{next} and \texttt{prev} field of the unlinked node have been set to \texttt{null} (not shown).}
   \vspace*{-12pt}
   \label{fig:unlink-first}
\end{figure}
    
    \item Suppose the test of the first if-statement evaluates to true, but the test of the second if-statement evaluates to false: for node $x$, it holds that $\mathrm{next}(x)\neq\mathtt{null}$ and $\mathrm{prev}(x)=\mathtt{null}$. We thus know that the list consists of at least two nodes, and it is the first node we are unlinking. Thus, $I$ cannot be larger than 0. If the node index is zero, the class invariant is not proven automatically \citeSelf[2:40]{Bian2020unlink2truefalse}, but we have two open goals corresponding to the chain properties \ref{item:prev} and \ref{item:next}, cf. proof of \texttt{linkLast}. Our situation is different now, see Fig.~\ref{fig:unlink-first}. Here our insight applies: because of acyclicity, we know all nodes are different. Thus, an update of $\sigma[I]$'s fields do not affect the other nodes. When proving \ref{item:next} this is sufficient as no next field of nodes in the new chain are changed compared to the old heap \citeSelf[10:14-15:28]{Bian2020unlink2truefalse}. When proving \ref{item:prev}, we furthermore make a case distinction between the new first node and the other nodes: the former follows from the heap update, the latter from the old invariant \citeSelf[3:27-10:13]{Bian2020unlink2truefalse}.
    
    \item Suppose the test of the first if-statement evaluates to false, and the test of the second to true: for node $x$, it holds that $\mathrm{next}(x)=\mathtt{null}$ and $\mathrm{prev}(x)\neq\mathtt{null}$. This means that the list consists of at least two nodes, and it is the last node we are unlinking. Proof is similar to the previous case: see Fig.~\ref{fig:unlink-last} and \citeSelf{Bian2020unlink3falsetrue}.

\begin{figure}
   \centering
   \includegraphics[scale=1]{figures/linkedlist-unlink-last.eps}
   \caption{The heap before ($H_b$) consists of a chain $\sigma$ with $\ell(\sigma)\geq 2$. The dashed lines show which objects are identical in the heaps. Interpreting $\sigma[I]$ in the new heap is invalid, as $I=\ell(\sigma)$ in the new heap. The \texttt{last} field of linked list has changed (not shown), and the before last node in the old heap now has \texttt{null} as \texttt{next} field.}
   \vspace*{-12pt}
   \label{fig:unlink-last}
\end{figure}

    \item Suppose both tests of if-statements evaluate to false: for node $x$, it holds that $\mathrm{next}(x)\neq\mathtt{null}$ and $\mathrm{prev}(x)\neq\mathtt{null}$. This implies that the list consists of at least three nodes: where $x$ is some `interior' node. This part of the proof is the largest, as it involves many cast distinctions. Up to the point where the class invariant is established in the heap after, except for \ref{item:prev} and \ref{item:next}, goes as before. Keep in mind the situation as depicted in Fig.~\ref{fig:unlink-middle}, and see \citeSelf{Bian2020unlink4falsefalseprev,Bian2020unlink5falsefalsenext}.
    
\begin{figure}
   \centering
   \includegraphics[scale=1]{figures/linkedlist-unlink-middle.eps}
   \caption{The situation ($H_b$) consists of a chain $\sigma$ with $\ell(\sigma)\geq 3$. The index $I$ remains unchanged in the heaps, thus $\sigma[I]$ in the heap after is equal to $\sigma[I+1]$ in the heap before. The following fields are updated in the new heap: the \texttt{next} field of the node at $\sigma[I-1]$ in the old heap becomes the node at $\sigma[I+1]$ in the old heap, and the \texttt{prev} field of the node at $\sigma[I+1]$ in the old heap becomes the node at $\sigma[I-1]$ in the old heap. In the new heap these two nodes are present in succession in the chain, thus satisfying the chain properties \ref{item:prev} and \ref{item:next}.}
   \vspace*{-12pt}
   \label{fig:unlink-middle}
\end{figure}

    We distinguish the two cases:
    \begin{enumerate}\setcounter{enumii}{1}
        \item Establishing the \texttt{prev} field property of the chain involves the following observation: there are three cases. First case, for all nodes at an index $0\leq i< I$ in the old heap, we know they are identical to the nodes at the same index in the new heap. We know the heap is updated to assign the \texttt{prev} field of $\sigma[I+1]$ in the old heap, and by acyclicity we know this node is separate from the nodes all before $\sigma[I]$ in the old heap. Second case, $\sigma[I]$ interpreted in the new heap is identical to $\sigma[I+1]$ in the old heap, and precisely for this node the \texttt{prev} field was updated to become $\sigma[I-1]$ in the old heap (which is $\sigma[I]$ in the new heap). Third and last case, for all nodes at an index $I+1<i<\ell(\sigma)$ in the old heap, we know they are identical to the nodes at $\sigma[i-1]$ in the new heap. Again, by acyclicity we know that the node $\sigma[I+1]$ in the old heap is separate from the nodes with a higher index, so we know their \texttt{prev} field cannot be affected by the update.
        \item Establishing the \texttt{next} fields property of the chain is very similar, but with the index offset by one. Observe that the \texttt{next} field of $\sigma[I-1]$ in the old heap is updated to $\sigma[I+1]$ in the old heap. Thus the three cases are: first, for the nodes with index $0\leq i < I-1$ in the old heap, second, for the node $\sigma[I-1]$ in the old heap, and third, for the nodes with index $I<i<\ell(\sigma)$ in the old heap.
    \end{enumerate}
\end{enumerate}
\vspace*{-24pt}
\end{proof}

Now that we have established that \texttt{unlink} removes a node from the chain while maintaining the class invariant, we can return to the verification of the \texttt{remove} method. The remove method iterates over the linked list until it has obtained a node to remove. However, the termination of this iteration is not obvious. Moreover, before invoking the \texttt{unlink} method, we need to specify the value of its ghost parameter: the index corresponding to the node. So, before we can verify the \texttt{remove} method, we add three kinds of annotations to its source: a ghost variable for maintaining the current index, a loop invariant that establishes termination and maintains the class invariant, and a set annotation before invoking the \texttt{unlink} method. See Listing~\ref{lst:remove-method-annot}.

%bump page
\pagebreak

\lstinputlisting[numbers=none,caption={The JML annotations of method \texttt{remove}. We use a slightly unnatural initial value for the index ghost variable, since the KeY 2.6.3 parser does not recognize the @set annotation if it appears after the if-statement.},captionpos=b,label={lst:remove-method-annot}]{figures/remove_method_annot.java}

The verification of above method is not fully automatic, see \citeSelf{Bian2020remove1null,Bian2020remove2nonnull}. The proof consists of two parts, corresponding to the branches of the if-statement. In the proof, one shows (among other properties) that the loop invariant holds  initially, after each iteration, and at the end of the loop. It is important to note that $(\mathit{index}+1)$ is equal to the length of the chain precisely when the end of the loop has been reached. This holds since we use the \texttt{next} field to traverse the chain, and only the last node has a \texttt{null} successor. Moreover, the distance to the last node decreases each iteration, and this distance is bounded from below by zero: thus the loop must terminate. Moreover, the loop is \emph{strictly pure}, as it never modifies the heap in any of its completed iterations. The exceptional case is the last iteration in which the \texttt{remove} method returns early. Due to the early return, the loop invariant no longer needs to be shown (and so also not its heap purity). For reasons of limited space, further examination of its proof is left as a challenge to the reader.

\section{Conclusion}\label{sec:conclusion}

Over the course of this paper, we have studied two essential methods of Java's \texttt{LinkedList} class: \texttt{add} and \texttt{remove}. The original implementation contains an overflow bug, and we have looked at a revised version that imposes a maximum length of the list. Furthermore, we have set out to verify that the overflow bug indeed no longer occurs. Towards this end, we have formally specified a class invariant and method contracts, with two goals: establishing the absence of the overflow bug, and capturing the `essential' behavior of the methods with respect to the structural properties of the linked list. All methods have been formally verified \citeSelf{10.5281/zenodo.3613712} using the KeY theorem prover, and video material shows how \citeSelf{Bian2020collection}.

A number of proof challenges were left for the reader:

\begin{challenge}
Describe (informally) the high-level steps of the correctness proof of \texttt{remove}.
\end{challenge}

\begin{challenge}
The proofs shown in the videos may not be the shortest and could contain detours: find proofs that have a fewer number of (interactive) steps.
\end{challenge}

\begin{challenge}
Make use of \texttt{assignable} and \texttt{accessible} clauses in JML with dynamic footprints (see \cite[Section 9.3]{KeYbook}): does this make the proofs shorter?
\end{challenge}

\begin{challenge}
Write a specification and verify the correctness for these linked list methods: \texttt{linkFirst}, \texttt{linkBefore}, \texttt{node}, \texttt{indexOf}, \texttt{clear}.
\end{challenge}

\begin{challenge}
Refine the specifications to relate the items in the `heap before' to the items in the `heap after', e.g.~all items in the heap before \texttt{add} is called must remain at the same position in the heap after, and verify the correctness with respect to the refined contracts.
\end{challenge}

\begin{challenge}
Abstract the specifications from properties related to items, i.e.~only show that the class invariant is maintained by the methods: can the proof still be done?
\end{challenge}

\bibliographystyleSelf{splncs04}
\bibliographySelf{self}

\bibliographystyle{splncs04}
\bibliography{base}

\end{document}
\endinput
